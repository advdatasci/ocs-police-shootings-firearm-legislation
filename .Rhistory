# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
popdensity <- merge(density,landSqMi,by="NAME")
head(popdensity)
head(density)
head(landSqMi)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
library(dplyr)
density <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(totalPop = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
levels(landSqMi$NAME) <- tolower(landSqMi$NAME))
library(dplyr)
density <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(totalPop = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
levels(landSqMi$NAME) <- tolower(landSqMi$NAME)
#popdensity <- merge(density,landSqMi,by="NAME")
head(popdensity)
head(density)
head(landSqMi)
library(dplyr)
density <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(totalPop = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- tolower(landSqMi$NAME)
#popdensity <- merge(density,landSqMi,by="NAME")
head(popdensity)
head(density)
head(landSqMi)
library(dplyr)
density <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(totalPop = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- tolower(landSqMi$NAME)
density$NAME <- tolower(density$NAME)
#popdensity <- merge(density,landSqMi,by="NAME")
head(popdensity)
head(density)
head(landSqMi)
library(dplyr)
density <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(totalPop = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- tolower(landSqMi$NAME)
density$NAME <- tolower(density$NAME)
popdensity <- merge(density,landSqMi,by="NAME")
head(popdensity)
head(density)
head(landSqMi)
View(popdensity)
library(dplyr)
density <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(totalPop = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- toupper(landSqMi$NAME)
density$NAME <- toupper(density$NAME)
popdensity <- merge(density,landSqMi,by="NAME")
head(popdensity)
head(density)
head(landSqMi)
library(dplyr)
totalPop <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(total = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- toupper(landSqMi$NAME)
totalPop$NAME <- toupper(totalPop$NAME)
popdensity <- merge(totalPop,landSqMi,by="NAME")
head(landSqMi)
library(dplyr)
totalPop <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(total = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- toupper(landSqMi$NAME)
totalPop$NAME <- toupper(totalPop$NAME)
popdensity <- merge(totalPop,landSqMi,by="NAME")
head(popdensity)
library(dplyr)
totalPop <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(total = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D)
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- toupper(landSqMi$NAME)
totalPop$NAME <- toupper(totalPop$NAME)
popdensity <- merge(totalPop,landSqMi,by="NAME")
popdensity$density <- popdensity$total/popdensity$LandAreaSqMiles
head(popdensity)
View(fatal_gunshot)
# first combine the two years of data
counted1516 <- rbind(counted15, counted16)
View(counted1516)
# "We calculated descriptive statistics for the proportion of victims that were male, armed, and non-White."
fatal_gunshot <- counted1516 %>%
filter(classification == "Gunshot",raceethnicity != "white", armed != "No", gender = "Male") %>%
group_by(state) %>% #group by the state
tally() # just count the number of observations in each of the grouped categories
# "We calculated descriptive statistics for the proportion of victims that were male, armed, and non-White."
fatal_gunshot <- counted1516 %>%
filter(classification == "Gunshot",raceethnicity != "white", armed != "No", gender == "Male") %>%
group_by(state) %>% #group by the state
tally() # just count the number of observations in each of the grouped categories
head(fatal_gunshot)
# first combine the two years of data
counted1516 <- rbind(counted15, counted16)
counted1516$state <- abbr2state(counted1516$state)
install.packages("openintro")
# first combine the two years of data
# install.packages("openintro")
library(openintro)
counted1516 <- rbind(counted15, counted16)
counted1516$state <- abbr2state(counted1516$state)
# first combine the two years of data
# install.packages("openintro")
library(openintro)
counted1516 <- rbind(counted15, counted16)
counted1516$state <- abbr2state(counted1516$state)
head(counted1516)
# first combine the two years of data
# install.packages("openintro")
library(openintro)
counted1516 <- rbind(counted15, counted16)
counted1516$state <-toupper(abbr2state(counted1516$state))
head(counted1516)
# "We calculated descriptive statistics for the proportion of victims that were male, armed, and non-White."
fatal_gunshot <- counted1516 %>%
filter(classification == "Gunshot",raceethnicity != "white", armed != "No", gender == "Male") %>%
group_by(state) %>% #group by the state
tally() # just count the number of observations in each of the grouped categories
head(fatal_gunshot)
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
#census data
census <- read.csv("sc-est2017-alldata6.csv",nrows = 236900,stringsAsFactors = FALSE)
head(census[, 1:5])
# Brady scores
brady <- read_excel("Brady-State-Scorecard-2015.xlsx", sheet = 1)
head(brady[, 1:5])
# The Counted data
counted15 <- read.csv("the-counted-2015.csv",stringsAsFactors = FALSE)
counted16 <- read.csv("the-counted-2016.csv",stringsAsFactors = FALSE)
head(counted15[, 1:5])
# Crime data
crime <- read_excel("table_5_crime_in_the_united_states_by_state_2015.xls", sheet = 1,skip = 3)
head(crime[, 1:5])
# Land area data
land <- read_excel("LND01.xls", sheet = 1)
head(land[, 1:5])
library(dplyr)
maleStats <- census %>%
filter(ORIGIN == 0) %>% #set origin to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(percentMale = sum(POPESTIMATE2015[SEX==1])/sum(POPESTIMATE2015[SEX==0])*100) #divide total male by total  population
head(maleStats)
library(dplyr)
library(tidyr)
library(data.table)
ageStats <- census %>%
filter(ORIGIN == 0,SEX == 0) %>% #set origin and sex to "Total" so we don't have repeats in the data.
group_by(NAME,AGE) %>% #group by state and age
summarize(sumAges = sum(POPESTIMATE2015)) #divide total male by total  population
head(ageStats)
# transform matrix to have state names as column heaeders
ageStats <- dcast(setDT(ageStats), AGE ~ NAME, value.var="sumAges")
ageStats$AGE <- NULL #get rid of the age columns since we can just use the index minus 1
ageStats <- apply(ageStats, 2, cumsum) # take the cumulative sum of each column
ageStats <- as.data.frame(ageStats) # convert back to a dataframe
ageStats <- apply(ageStats,2,function(x) x/x[86]) # divide each column by the last value, showing the cumulative sum at that age as a percentile
ageStats <- as.data.frame(ageStats) # convert back to a dataframe
# now we have a percentile associated with each age
# now we just need to get the age of the 50th percentile for each state...
head(ageStats[, 1:6])
median <- apply(ageStats,2,function(x) which.max(x >= 0.5)-1)
medians <- as.data.frame(median)
head(medians)
library(dplyr)
raceStats <- census %>%
filter(ORIGIN == 0, SEX == 0) %>% #set origin and sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(percentWhite = sum(POPESTIMATE2015[RACE==1])/sum(POPESTIMATE2015)*100,
percentBlack = sum(POPESTIMATE2015[RACE==2])/sum(POPESTIMATE2015)*100)
head(raceStats)
originStats <- census %>%
filter(SEX == 0) %>% #set origin and sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(percentHispanic = sum(POPESTIMATE2015[ORIGIN==2])/sum(POPESTIMATE2015[ORIGIN==0])*100)
head(originStats)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup
violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
violentcrime[10:20,]
# I really want the "Rate per 100,000 inhabitants" for violent crime for each state.
violentcrime<- subset(violentcrime, X__1 == "Rate per 100,000 inhabitants")
violentcrime$X__1 <- NULL
names(violentcrime) <- c("State", "Violent_Crime_rate_per_100,000")
head(violentcrime)
# Looking at our dataframe we can see some of the state names have numbers in them. This will make it hard to later merge this data together, so we should clean this up.
violentcrime$State<-gsub('[0-9]+', '', violentcrime$State)
#install.packages("rJava")
#install.packages(c("NLP", "openNLP", "RWeka", "qdap"))
require(rJava)
require(openNLP)
library(rJava)
library(NLP)
library(openNLP)
#library(RWeka)
PHlaws <- readLines("supplemental table a. .txt")
blaws <- brady[1]
# first combine the two years of data
# install.packages("openintro")
library(openintro)
counted1516 <- rbind(counted15, counted16)
counted1516$state <-toupper(abbr2state(counted1516$state))
head(counted1516)
# install.packages("rvest")
library(rvest)
url <- read_html("https://www.bls.gov/lau/lastrk15.htm")
datavalues <- url%>%
html_nodes('.datavalue') %>% # html_nodes acts as a CSS selector
html_text() %>%
as.numeric()
state <- url%>%
html_nodes('.sub0') %>%
html_text()
unemployment<-as.data.frame(state[c(2:52)]) # the first listing is united states and we don't need that
# since "datavalue" was the class name for both fields, we need to seperate them by taking every other entry as rank and every other as unemployment rate
# skip the first two entries
rate_select <- seq(3,103,by=2)
rank_select <- seq(4,104,by=2)
unemployment$rate <- datavalues[rate_select]
unemployment$rank <- datavalues[rank_select]
head(unemployment)
library(dplyr)
totalPop <- census %>%
filter(ORIGIN == 0, SEX == 0 ) %>% #set origin & sex to "Total" so we don't have repeats in the data.
group_by(NAME) %>% #group by the state
summarize(total = sum(POPESTIMATE2015)) #divide total male by total
landSqMi <- land %>%
select(Areaname,LND110210D) # I selected LND110210D because I looked at the data table at https://www.census.gov/geo/reference/state-area.html and compared values to find the correct column. This one corresponds to land area in square miles
# Now we just need to do an inner merge on the state and areaname so that we just get the area for each state.
names(landSqMi) <- c("NAME", "LandAreaSqMiles")
landSqMi$NAME <- toupper(landSqMi$NAME) # need to make both columns
totalPop$NAME <- toupper(totalPop$NAME)
popdensity <- merge(totalPop,landSqMi,by="NAME")
popdensity$density <- popdensity$total/popdensity$LandAreaSqMiles
head(popdensity)
# "We calculated descriptive statistics for the proportion of victims that were male, armed, and non-White."
fatal_gunshot <- counted1516 %>%
filter(classification == "Gunshot",raceethnicity != "white", armed != "No", gender == "Male") %>%
group_by(state) %>% #group by the state
tally() # just count the number of observations in each of the grouped categories
head(fatal_gunshot)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup
(violentcrime2)
violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
violentcrime[10:20,]
# I really want the "Rate per 100,000 inhabitants" for violent crime for each state.
violentcrime<- subset(violentcrime, X__1 == "Rate per 100,000 inhabitants")
violentcrime$X__1 <- NULL
names(violentcrime) <- c("State", "Violent_Crime_rate_per_100,000")
head(violentcrime)
# Looking at our dataframe we can see some of the state names have numbers in them. This will make it hard to later merge this data together, so we should clean this up.
violentcrime$State<-gsub('[0-9]+', '', violentcrime$State)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
violentcrime$State <- na.locf(violentcrime$State)
(violentcrime)
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup
(violentcrime2)
violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
violentcrime[10:20,]
# I really want the "Rate per 100,000 inhabitants" for violent crime for each state.
violentcrime<- subset(violentcrime, X__1 == "Rate per 100,000 inhabitants")
violentcrime$X__1 <- NULL
names(violentcrime) <- c("State", "Violent_Crime_rate_per_100,000")
head(violentcrime)
# Looking at our dataframe we can see some of the state names have numbers in them. This will make it hard to later merge this data together, so we should clean this up.
violentcrime$State<-gsub('[0-9]+', '', violentcrime$State)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime2<- violentcrime %>%
select(State) %>%
group_by(State) %>%
na.locf %>%
ungroup
(violentcrime2)
violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
violentcrime[10:20,]
# I really want the "Rate per 100,000 inhabitants" for violent crime for each state.
violentcrime<- subset(violentcrime, X__1 == "Rate per 100,000 inhabitants")
violentcrime$X__1 <- NULL
names(violentcrime) <- c("State", "Violent_Crime_rate_per_100,000")
head(violentcrime)
# Looking at our dataframe we can see some of the state names have numbers in them. This will make it hard to later merge this data together, so we should clean this up.
violentcrime$State<-gsub('[0-9]+', '', violentcrime$State)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup
(violentcrime2)
violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
violentcrime[10:20,]
# I really want the "Rate per 100,000 inhabitants" for violent crime for each state.
violentcrime<- subset(violentcrime, X__1 == "Rate per 100,000 inhabitants")
violentcrime$X__1 <- NULL
names(violentcrime) <- c("State", "Violent_Crime_rate_per_100,000")
head(violentcrime)
# Looking at our dataframe we can see some of the state names have numbers in them. This will make it hard to later merge this data together, so we should clean this up.
violentcrime$State<-gsub('[0-9]+', '', violentcrime$State)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup %>%
.$State
(violentcrime2)
violentcrime2[10:20,]
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup %>%
.$State
(violentcrime2)
#violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup %>%
pull(State)
(violentcrime2)
#violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
View(violentcrime)
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime$State<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup %>%
pull(State)
(violentcrime)
#violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
library(dplyr)
library(zoo)
head(crime)
# Selecting "Violent crime1" was not working, so I printed "colnames(crime)" to see that there are some extraneous characters in the names. Instead I take the index from the column names. I also could probably just select the index of the columns.
violentcrime<- crime %>%
select("State",colnames(crime)[3], colnames(crime)[5])
violentcrime[10:20,]
#violentcrime$State <- na.locf(violentcrime$State)
#(violentcrime)
violentcrime2<- violentcrime %>%
group_by(State) %>%
na.locf %>%
ungroup
violentcrime2[10:20,]
# Hmm..I don't want to fill na for the other columns just yet because now there are duplicate rows with different states, making it confusing.
# Let's do a quick fix
violentcrime$State <- violentcrime2$State
violentcrime[10:20,]
# I really want the "Rate per 100,000 inhabitants" for violent crime for each state.
violentcrime<- subset(violentcrime, X__1 == "Rate per 100,000 inhabitants")
violentcrime$X__1 <- NULL
names(violentcrime) <- c("State", "Violent_Crime_rate_per_100,000")
head(violentcrime)
# Looking at our dataframe we can see some of the state names have numbers in them. This will make it hard to later merge this data together, so we should clean this up.
violentcrime$State<-gsub('[0-9]+', '', violentcrime$State)
